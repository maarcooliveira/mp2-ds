package chord;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.LinkedList;
import java.util.List;

/**
 * Defines behavior for chord.Coordinator thread.
 *
 * @author Bruno de Nadai Sarnaglia <denandai2@illinois.edu>
 * @version 1.0
 */
public class Coordinator extends Thread {

    public static final int BASE_PORT = 9000;
    private static volatile Integer[] listOfPorts = new Integer[256];
    private static volatile List<String> messageQueue = new LinkedList<String>();
    private static volatile int numNodes;
    private static volatile boolean ackReceived = true;
    private static volatile int acksToWait = 0;
    private static volatile int ackCount = 0;
    public static final int COORDINATOR_PORT = 9999;
    public static volatile double MSG_COUNT = 0;
    public static volatile double CALL_COUNT = 0;

    public Coordinator() {
        numNodes = 0;
        new CommandManager().start();
        new Listener().start();
    }

    public static void joinNode(int port) {
        numNodes++;
        listOfPorts[port] = BASE_PORT + port;
        sendMessage("join " + port, listOfPorts[port]);

        while(ackCount < 1) {}
        broadcast("joined " + port);
    }

    /**
     * Runs the coordinator thread.
     */
    @Override
    public void run() {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        while (true) {
            try {
                String input = bufferedReader.readLine();
                if (input != null && input.equals("exit")) {
                    System.exit(0);
                }
                if (validInput(input)) {
                    CALL_COUNT++;
                    messageQueue.add(input);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Sends a message to a given port (thread) in the system.
     *
     * @param message a string containing commands for the thread.
     * @param port    the port for that thread.
     */
    private static void sendMessage(String message, int port) {

        try {
            Socket socket = new Socket("127.0.0.1", port);
            DataOutputStream dataOutputStream = new DataOutputStream(socket.getOutputStream());
            dataOutputStream.writeBytes(message);
            dataOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void broadcast(String message) {
        Integer avoid = null;
        String[] cmd = message.split(" ");

        if (cmd.length == 2 && cmd[0].equals("joined"))
            avoid = Integer.valueOf(cmd[1]);
        int sendCount = ackCount;

        for (int p = 0; p < Main.TOTAL_KEYS; p++) {
            if (listOfPorts[p] != null && (avoid == null || (avoid != null && p != avoid))) {
                while(ackCount < sendCount) {}
                sendMessage(message, listOfPorts[p]);
                sendCount = sendCount + 1;
            }
        }
    }

    /**
     * Executes a command given by the user.
     *
     * @param input a string generated by user input.
     */
    private static void executeCommand(String input) {
        String[] listArgs = input.split(" ");

        // join p
        if (listArgs[0].equals("join")) {
            int port = Integer.parseInt(listArgs[1]);

            if (listOfPorts[port] == null) {
                Node n = new Node(port);
                joinNode(port);
            }
        }

        // find p k
        else if (listArgs[0].equals("find")) {
            int port = Integer.parseInt(listArgs[1]);

            if (listOfPorts[port] != null) {
                sendMessage(input, listOfPorts[port]);
            }
        }

        // leave p
        else if (listArgs[0].equals("leave")) {
            int port = Integer.parseInt(listArgs[1]);

            if (listOfPorts[port] != null) {
                numNodes--;
                broadcast("left " + port);
                sendMessage(input, listOfPorts[port]);
                listOfPorts[port] = null;
            }
        }

        // show p (or show all)
        else if (listArgs[0].equals("show")) {
            if (!listArgs[1].equals("all")) {
                int port = Integer.parseInt(listArgs[1]);

                if (listOfPorts[port] != null)
                    sendMessage(input, listOfPorts[port]);
            } else { //is show all
                broadcast("show all");
            }
        }

        else if (listArgs[0].equals("stabilize")) {
            broadcast("joined 0");
        }
    }

    /**
     * Checks if the input is valid.
     *
     * @param input a string generated by user input.
     * @return <em>true</em> if the input is valid, and an STDOUT message indicating the problem if <em>false</em>.
     */
    private boolean validInput(String input) {
        if (input == null) {
            System.out.println("command not valid");
            return false;
        }

        String[] listArgs = input.split(" ");

        if (listArgs[0].equals("avg")) {
            System.out.println(MSG_COUNT/CALL_COUNT);
            return false;
        }

        else if (listArgs[0].equals("clr")) {
            MSG_COUNT = 0;
            CALL_COUNT = 0;
            return false;
        }

        else if (listArgs[0].equals("stabilize")) {
            return true;
        }

        else if (listArgs[0].equals("join")) {
            if (listArgs.length != 2) {
                System.out.println("join <node>");
                return false;
            }
            if (!isNumber(listArgs[1])) {
                System.out.println("<node> should be an integer from 0 to 255");
                return false;
            }
            return true;
        }

        else if (listArgs[0].equals("find")) {
            if (listArgs.length != 3) {
                System.out.println("find <node> <node>");
                return false;
            }
            if (!isNumber(listArgs[1]) || !isNumber(listArgs[2])) {
                System.out.println("<node> should be an integer from 0 to 255");
                return false;
            }
            return true;
        }

        else if (listArgs[0].equals("leave")) {
            if (listArgs.length != 2) {
                System.out.println("leave <node>");
                return false;
            }
            if (!isNumber(listArgs[1])) {
                System.out.println("<node> should be an integer from 0 to 255");
                return false;
            }
            return true;
        }

        else if (listArgs[0].equals("show")) {
            if (listArgs.length != 2) {
                System.out.println("show <node> OR show all");
                return false;
            }
            if (listArgs[1].equals("all")) {
                return true;
            }
            if (!isNumber(listArgs[1])) {
                System.out.println("<node> should be an integer from 0 to 255");
                return false;
            }
            return true;
        }

        System.out.println("command not valid");
        return false;
    }

    /**
     * Checks if a given string corresponds to a valid node number.
     *
     * @param node a string containing a node's number on the system.
     * @return <em>true</em> if the string corresponds to a number between 0 and 255 (inclusive).
     */
    private boolean isNumber(String node) {
        try {
            int i = Integer.parseInt(node);
            if (i < 0 || i > 255) {
                return false;
            }
        } catch (NumberFormatException e) {
            return false;
        }
        return true;
    }


    private static class CommandManager extends Thread {

        public void run() {
            while (true) {
                if (messageQueue.size() > 0 && ackReceived) {
                    String message = messageQueue.remove(0);
                    String[] listArgs = message.split(" ");
                    String c = listArgs[0];

                    if (c.equals("join") || c.equals("leave") || c.equals("joined") || c.equals("left")) {
                        int port = Integer.parseInt(listArgs[1]);

                        if (c.equals("join") && listOfPorts[port] != null) {
                            ackCount = 0;
                            acksToWait = 0;
                            ackReceived = true;
                        }
                        else {
                            ackCount = 0;
                            acksToWait = numNodes + 1;
                            ackReceived = false;
                        }
                    }

                    else if (c.equals("show")) {
                        if(listArgs[1].equals("all")) {
                            ackCount = 0;
                            acksToWait = numNodes;
                            ackReceived = false;
                        }
                        else if (listOfPorts[Integer.valueOf(listArgs[1])] != null) {
                            ackCount = 0;
                            acksToWait = 1;
                            ackReceived = false;
                        }
                    }

                    else if (c.equals("find")) {
                        ackCount = 0;
                        acksToWait = 1;
                        ackReceived = false;
                    }

                    else if (c.equals("stabilize")) {
                        ackCount = 0;
                        acksToWait = numNodes - 1;
                        if (acksToWait == 0)
                            ackReceived = true;
                        else
                            ackReceived = false;
                    }

                    else {
                        ackCount = 0;
                        acksToWait = 0;
                        ackReceived = true;
                    }

                    executeCommand(message);
                }
            }
        }
    }


    private static class Listener extends Thread {

        /**
         * Runs the server thread, receiving messages and responding to them accordingly.
         */
        public void run() {
            try {
                ServerSocket listener;
                listener = new ServerSocket(COORDINATOR_PORT);

                while (true) {
                    Socket socket = listener.accept();
                    BufferedReader fromNode = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                    String message = fromNode.readLine();
                    String[] listArgs = message.split(" ");

                    if (listArgs[0].equals("ack")) {

                        if (listArgs.length == 5 && listArgs[1].equals("find")) {
                            System.out.println(listArgs[4]);
                            ackCount = ackCount + 1;

                            if (!ackReceived && ackCount >= acksToWait) {
                                acksToWait = 0;
                                ackReceived = true;
                            }
                        }
                        else {

                            ackCount = ackCount + 1;
                        }

                        if(!ackReceived && ackCount >= acksToWait) {
                            acksToWait = 0;
                            ackCount = 0;
                            ackReceived = true;
                        }
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}